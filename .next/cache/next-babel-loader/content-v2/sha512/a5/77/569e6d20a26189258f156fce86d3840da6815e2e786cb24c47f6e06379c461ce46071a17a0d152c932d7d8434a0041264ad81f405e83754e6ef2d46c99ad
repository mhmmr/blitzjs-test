{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { resolver, SecurePassword, hash256 } from \"blitz\";\nimport db from \"db\";\nimport { ResetPassword } from \"app/auth/validations\";\nimport login from \"app/auth/mutations/login\";\nexport class ResetPasswordError extends Error {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"name\", \"ResetPasswordError\");\n\n    _defineProperty(this, \"message\", \"Reset password link is invalid or it has expired.\");\n  }\n\n}\nexport default resolver.pipe(resolver.zod(ResetPassword), async ({\n  password,\n  token\n}, ctx) => {\n  // 1. Try to find this token in the database\n  const hashedToken = hash256(token);\n  const possibleToken = await db.token.findFirst({\n    where: {\n      hashedToken,\n      type: \"RESET_PASSWORD\"\n    },\n    include: {\n      user: true\n    }\n  }); // 2. If token not found, error\n\n  if (!possibleToken) {\n    throw new ResetPasswordError();\n  }\n\n  const savedToken = possibleToken; // 3. Delete token so it can't be used again\n\n  await db.token.delete({\n    where: {\n      id: savedToken.id\n    }\n  }); // 4. If token has expired, error\n\n  if (savedToken.expiresAt < new Date()) {\n    throw new ResetPasswordError();\n  } // 5. Since token is valid, now we can update the user's password\n\n\n  const hashedPassword = await SecurePassword.hash(password);\n  const user = await db.user.update({\n    where: {\n      id: savedToken.userId\n    },\n    data: {\n      hashedPassword\n    }\n  }); // 6. Revoke all existing login sessions for this user\n\n  await db.session.deleteMany({\n    where: {\n      userId: user.id\n    }\n  }); // 7. Now log the user in with the new credentials\n\n  await login({\n    email: user.email,\n    password\n  }, ctx);\n  return true;\n});","map":null,"metadata":{},"sourceType":"module"}