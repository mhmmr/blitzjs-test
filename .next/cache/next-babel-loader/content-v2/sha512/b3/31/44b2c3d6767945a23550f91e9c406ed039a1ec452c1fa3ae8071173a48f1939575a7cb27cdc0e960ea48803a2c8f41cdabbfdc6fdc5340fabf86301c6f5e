{"ast":null,"code":"import { resolver, generateToken, hash256 } from \"blitz\";\nimport db from \"db\";\nimport { forgotPasswordMailer } from \"mailers/forgotPasswordMailer\";\nimport { ForgotPassword } from \"app/auth/validations\";\nconst RESET_PASSWORD_TOKEN_EXPIRATION_IN_HOURS = 4;\nexport default resolver.pipe(resolver.zod(ForgotPassword), async ({\n  email\n}) => {\n  // 1. Get the user\n  const user = await db.user.findFirst({\n    where: {\n      email: email.toLowerCase()\n    }\n  }); // 2. Generate the token and expiration date.\n\n  const token = generateToken();\n  const hashedToken = hash256(token);\n  const expiresAt = new Date();\n  expiresAt.setHours(expiresAt.getHours() + RESET_PASSWORD_TOKEN_EXPIRATION_IN_HOURS); // 3. If user with this email was found\n\n  if (user) {\n    // 4. Delete any existing password reset tokens\n    await db.token.deleteMany({\n      where: {\n        type: \"RESET_PASSWORD\",\n        userId: user.id\n      }\n    }); // 5. Save this new token in the database.\n\n    await db.token.create({\n      data: {\n        user: {\n          connect: {\n            id: user.id\n          }\n        },\n        type: \"RESET_PASSWORD\",\n        expiresAt,\n        hashedToken,\n        sentTo: user.email\n      }\n    }); // 6. Send the email\n\n    await forgotPasswordMailer({\n      to: user.email,\n      token\n    }).send();\n  } else {\n    // 7. If no user found wait the same time so attackers can't tell the difference\n    await new Promise(resolve => setTimeout(resolve, 750));\n  } // 8. Return the same result whether a password reset email was sent or not\n\n\n  return;\n});","map":null,"metadata":{},"sourceType":"module"}